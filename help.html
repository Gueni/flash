
<!DOCTYPE html>

<html lang="en">


<head>

    <title></title>


<style>
body {background-color: transparent;}
h1   {color: black; font-size: 90px;
    font-weight: bold;
    font-family: bold;
}
h2   {color: #0277BD; font-size: 60px}

p    {color: black;font-size:14px ;line-height: 1.5;}
hr   {
    font-size: 1.5px;
    color: rgba(0, 0, 0, 0);
    line-height: 2px;

    background-color: grey;
    margin-top: -6px;
    margin-bottom: 10px;
}

</style>

</head>
<body>
<br>
<center><img hspace="100" src="icons/espLogo.png" alt="MicroTool Logo"></center>
<br>
<h1 ><b>Getting started</b></h1>
<hr>
<p> MicroTool is a free software which allows the user to access, flash and erase the ESP32 and ESP8266 internal memory.
    <br>Meanwhile , MicroTool introduces the set of features mentioned in the sections below.</p>
<br>
<p align="justify ">
     The software is divided into two major modes, production mode and advanced mode. The
     production mode is a simple user interface containing the minimum number of features
     allowing the operator to conduct the necessary flashing and or flash erasing procedures<br>
     with minimum complexity and errors.The advanced mode on the other hand is more complex
     and sums up all the features and<br> commands made possible with the esptool  library but with an
     easier and more advanced user experience.
</p>
<br>
<h1 ><b>Features</b></h1>
<hr>
<br>
<h2>Serial Port</h2>
<hr>
<p>
    The serial port is selected using the ComboBox Designated Serial Port, like COM1
    (Windows). If no option is specified,esptool will<br> enumerate all connected serial ports and
    try each one until it finds an Espressif device (ESP32 or ESP8266) connected.
</p>
<br>

<h2>Baud rate</h2>
<hr>
<p>
    The default baud rate is 115200bps. Different rates may be set using the Baud Rate ComboBox.
    This can speed up writing and<br> reading flash operations.The baud rate is limited to 115200 when
    initial connection is established,higher speeds are only used for data <br>transfers.
    Most hardware configurations will work with 230400, some with 460800, 921600 and/or
    1500000 or higher.If you have <br>connectivity problems then you can also set baud rates
    below 115200. You can also choose 74880, which is the usual baud rate<br> used by the ESP8266
    to output boot log information.
</p>
<br>



<h2>Flash Firmware/Bootloader</h2>
<hr>
<p>
    Binary data (Multiple flash addresses and file)can be written to the ESP's flash chip.
    The chip selection is optional when writing to ESP<br> flash, as it will be detected when it
    connects to the serial port.The offset (address) and file name are crucial for this operation.<br>
    The file names created by "ELF to Bin" include the flash offsets as part of the
    file name. For other types of images, <br>consult your SDK documentation to determine the
    files to flash at which offsets.Numeric values passed as offset address can only<br> be specified
    in hex (ie 0x1000).
</p>
<br>

<h2>Setting Flash Mode and Size</h2>
<hr>
<p>
    You may also need to specify flash mode and flash size, if you wish to
    override the defaults.
</p>
<br>

<h2>Compression</h2>
<hr>
<p>
    By default, the serial transfered data is compressed (by esptool.py) for better performance.
</p>
<br>

<h2>Read Flash Contents</h2>
<hr>
<p>
    The Read flash feature allows reading back the contents of flash. for that you need to
    specify an address, a size, and a filename to <br>dump the output to.
</p>
<br>

<h2>Erase Flash: erase flash & erase region</h2>
<hr>
<p>
    To erase the entire flash chip (all data replaced with 0xFF bytes)
    To erase a region of the flash, for example starting at an address <br>(ie:0x20000)with a length (ie 0x4000 bytes) (16KB)
    The address and length must both be multiples of the SPI flash erase sector<br> size. This is
    0x1000 (4096) bytes for supported flash chips.
</p>
<br>


<h2>Convert ELF to Binary</h2>
<hr>
<p>
    Converts an ELF file into the binary executable images which can be flashed and then booted into the chip.
    This command does not<br> require a serial connection.
</p>
<br>

<h2>Output bin image details: image info</h2>
<hr>
<p>
    The image info  outputs some information (load addresses, sizes, etc) about a .bin file.
</p>
<br>

<h2>Verify flash</h2>
<hr>
<p>
    Allows you to verify that data in flash matches a local file. Additional verification is not usually needed.
    However, if you wish to perform<br> a byte-by-byte verification of the flash contents then you can do so with this feature.
</p>
<br>

<h2>Dump Memory</h2>
<hr>
<p>
    Will dump a region from the chip's memory space to a file.
</p>
<br>

<h2>load RAM</h2>
<hr>
<p>
    Allows the loading of an executable binary image directly into RAM, and then immediately executes
    the program contained within it.<br>The binary image must only contain IRAM- and DRAM-resident segments.
    Any SPI flash mapped segments will not load correctly and<br> the image will probably crash.
    The image info can be used to check the binary image contents.
</p>
<br>

<h2>Read / write Memory</h2>
<hr>
<p>
    The read & write Memory allow reading and writing single words (4 bytes) of RAM. This can be used to
    "peek" and "poke" at registers.
</p>
<br>

<h2>Read flash status</h2>
<hr>
<p>
    Intended for use when debugging hardware flash chip-related problems. It allows sending a RDSR, RDSR2
    and/or RDSR3<br> command to the flash chip to read the status register contents. This can be used to
    check write protection status.<br>
    The bytes number determines how many status register bytes are read:<br>
     <ul>
          <li>bytes 1 sends the most common RDSR command (05h) and returns a single byte of status.</li>
          <li>bytes 2 sends both RDSR (05h) and RDSR2 (35h), reads one byte of status from each, and returns a two byte status.</li>
          <li>bytes 3 sends RDSR (05h), RDSR2 (35h), and RDSR3 (15h), reads one byte of status from each, and returns a 3 byte status.</li>
     </ul>
</p>
<br>

<h2>Write flash status</h2>
<hr>
<p>
    Intended for use when debugging hardware flash chip-related problems. It allows sending WRSR, WRSR2 and/or WRSR3
    commands<br>to the flash chip to write the status register contents. This can be used to clear write protection bits.
    The bytes option is similar to the<br> corresponding option for read flash status and causes a mix of WRSR (01h),
    WRSR2 (31h), and WRSR3 (11h) commands to be sent to the<br> chip. If bytes 2 is used then WRSR is sent first with a
    16-bit argument and then with an 8-bit argument. Otherwise, each command is<br> accompanied by 8-bits of the new
    status register value.

</p>
<br>

<h2>Chip Id</h2>
<hr>
<p>
    Allows you to read a 4 byte ID which forms part of the MAC address.
</p>
<br>

</body>

</html>

